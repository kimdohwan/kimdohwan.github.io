---
layout: post
title:  "이차원 배열 생성 시 asterisk(*) 와 for loop 사용의 차이점"
categories: Python
---


# 이차원 배열 생성과 값 변경

### 문제 상황

미로 생성 코드의 이차원 배열 생성 코드를 수정한 후 값 변경 시 모든 list 의 값이 변경됨

-   정상 코드(퍼온 코드)
    
    ```python
    vis = [[0] * self.w + [1] for _ in range(self.h)] + [[1] * (self.w + 1)]
    vis[0][1] = 1
    # 값 변경 전
    > [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
    # 값 변경 후
    > [[0, 1, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
    ```
    
-   문제 발생 코드(내가 작성)
    
    ```python
    vis = [[0] * self.w + [1]] * self.h + [[1] * self.w + 1]
    vis[0][1] = 1
    # 값 변경 전
    > [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
    # 값 변경 후 
    > [[0, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 1, 1]]
    ```
    
    vis\[0\]\[1\] 이라고 지정했음에도 vis 의 모든 값이 바뀌게되는 문제
    

### 문제 원인

이차원 배열 생성 시 asterisk(`*`) 를 사용해서 list 를 생성 했기 때문이다.  
정확히 말하자만 생성이 아니라 object 를 reference 한 코드로 동작한다.  
  
  
for loop 를 사용한 코드는 너무 보기 복잡해서 내 방식으로 코드를 수정해보았다.  
하지만 asterisk(`*`)와 for loop 의 list append 의 차이점을 제대로 인식하지 못했다.  
  
  
vis\[o\] = \[0, 1, 0, 0\] 으로 수정한다면 정상적으로 작동한다. 왜냐하면 vis\[0\] 의 참조값 자체를 바꿔주었기 때문이다. 현재 vis\[0\], vis\[1\], vis\[2\], vis\[3\] 은 모두 같은 참조값을 가지는 객체이다. 왜냐하면 asterisk(`*`)를 통해 값을 복사했기 때문이다.  
  
  
하지만 list comprehension 의 for loop 를 사용할 경우, data 는 같아도 서로 다른 참조값을 가지는 별개의 객체(vis\[0\], vis\[1\], vis\[2\], vis\[3\])를 가지게 된다.  
  

### 참고

위 상황은 mutable type object 인 list 이기 떄문에 발생한 문제이다.  
immutable type 일 경우 위와 같은 문제가 발생할 수 없다. 당연한 이야기.